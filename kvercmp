#!/usr/bin/awk -f 
#   Kernel version compare
#   Copyright (C) 2007  Michiel de Boer a.k.a. locsmif

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.

#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.

function usage() {
printf(	" %s %s %s %s %s %s %s %s %s %s", 
	"Kernel version compare - Copyright (C) 2007  Michiel de Boer a.k.a. locsmif\n",
	"Licensed under GPL version 2 or (at your option) any later version.\n\n",
	"kvercmp [-hi|-lo]\n",
	"Reads a list of versions from standard input. If both options are given\n",
	"simultaneously the result is always first the lowest, a single whitespace.\n",
	"then the highest.\n\n",
	"kvercmp <version> <-lt|-gt|-eq> <version>\n",
	"Compares if the version to the left is lesser or greater than, or equal to,\n",
	"the version to the right. Exit code is 0 if true, 1 if false.\n",
	"You can pass paths to kvercmp, but do not end them in a forward slash (/)\n\n")
	exit 1
}

function getvnum(line, digits, extra, numparts, vnrs, vnum) {
	# Try to keep as pure a version string as possible
	# Cut off all cruft up to it
	# First the path, up to the last /
	sub(/^.*\//, "", line)
	line = substr(line, match(line, /[0-9]\.[0-9].*/))
	# Get only the digits and the dots
	digits = substr(line, match(line, /^[0-9][0-9\.]*/), RLENGTH)
	#extra = line
	#sub(digits, "", extra)
	#print "extra='" extra "'"
	if (digits ~ /^[0-9][0-9\.]*$/) {
		numparts = split(digits, vnrs, ".")
		vnum = 0
		for (i=1;i<=numparts;i++) { 
			vnum += vnrs[i] * 100 ^ (4-i)
			#print "vnrs[i]=" vnrs[i] " vnum=" vnum
		} 
		return vnum
	}
	else {
		print "Failed to parse version string!"
		exit 2
	}
}

BEGIN {
	for (i = 1; i < ARGC; i++) p[i] = ARGV[i]
	i = 1
	while (i < ARGC) {
			
			if (p[i] ~ /^-hi$/) hi = 1
			else if (p[i] ~ /^-lo$/) lo = 1
			else if (p[i] ~ /^-/) usage()
			else { 
				v1 = p[i]
				#print "v1=" v1	
				
				if (p[++i] ~ /^-gt$/) gt = 1
				else if (p[i] ~ /^-lt$/) lt = 1
				else if (p[i] ~ /^-eq$/) eq = 1
				else usage()
				
				#print "gt=" gt " lt=" lt
				
				if (p[++i] ~ /^[^-]/) v2 = p[i]
				else usage()
				
				if (p[++i]) usage()
				break
			}
			#print "gt='" gt "' lt='" lt "' v1='" v1 "' v2='" v2 "' hi='" hi "' lo='" lo "'"
			i++
	}
	if (v1 && v2 && (gt || lt || eq)) {
			if ((lt && getvnum(v1) < getvnum(v2)) || (gt && getvnum(v1) > getvnum(v2)) || 
			(eq && getvnum(v1) == getvnum(v2))) exit 0
			exit 1
	}
	else if (!(hi || lo)) usage()
	ARGC = 0;
}

{ 
	line = $0
	#print "line=" line 
	sub(/^[^0-9]*/, "")
	vnum = getvnum($0)
	if (hi && vnum > max) { 
		max = vnum
		maxline = line
	}
	if (lo && (!min || vnum < min)) { 
		min = vnum
		minline = line
	}
	#print vnum
	#print "---"
}

END { 
	if (hi || lo) {
		print(minline ? maxline ? minline " " maxline : minline : maxline)
	}
}
