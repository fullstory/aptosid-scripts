#!/bin/sh

# Version: 2.2
# Date: 01 November 2007

# Please do not change the logic here, it makes it too hard to read linearly:
# [ ! -f somefile ] && do something is far easier to read than [ -f somefile ] || do something
# tempfile primary cleanup is now handled by called scripts, so no need to complicate this
# simple stub with the cleanup stuff. Now it just cleans up after itself each time.

# this will handle stub for any other script also
CALLER="$(basename $0)"
PREFIX="/usr/local/bin/"
UPSTREAM="http://techpatterns.com/downloads/distro/"
# Do  not create temp file here. It will create masses of temp files over time.
FILE_TEMP_NAME="" # will handle failed downloads

# catch unknown process terminations and clean up temporary files
trap 'error_handler 8' EXIT

error_handler()
{
	local message=''
	case $1 in
		1)
			message='You must be root to run this script!'
			;;
		2)
			message='Failed to download script properly. The file is empty!'
			;;
		3)
			message="${PREFIX}${SCRIPT} not executable!"
			;;
		4)
			message='Script download exited with errors.'
			;;
		5)
			message='Unknown script requested.'
			;;
		6)
			message='Failed to download script. The downloaded file does not exist!'
			;;
		7)
			message="${PREFIX}${SCRIPT} exec command failed with errors! Deleting problem file. Please try again."
			# this will handle, I think, partial, incomplete, downloads, that are not null
			[ -f "${PREFIX}${SCRIPT}" ] && rm -f "${PREFIX}${SCRIPT}"
			;;
		8)
			message="Manual user abort, clean up temporary files."
			;;
		*)
			message='Unknown error, exiting now.'
			;;
	esac

	echo "ERROR: $message - Error No: $1"

	# cleanup the temp file if error
	[ -f "$FILE_TEMP_NAME" ] && rm -f "$FILE_TEMP_NAME"
	exit $1
}

# set the SCRIPT value
case $CALLER in
	sgfxi|sm|smxi|du-fixes-h2.sh|svmi)
		SCRIPT="$CALLER"
		;;
	*)
		error_handler 5
		;;
esac

# this handles that annoying null file thing. Because -s is ambiguous, I added a -f check
# as well. Delete all existing null files. This test must be first. This won't handle incomplete
# downloads, but it will help a bit. This also avoids a file does not exist error
if [ -f "${PREFIX}${SCRIPT}" ] && [ ! -s "${PREFIX}${SCRIPT}" ]; then
	rm -f "${PREFIX}${SCRIPT}"
fi

# now that null files are removed, we can safely use the -x test. Note: be very careful
# relying on -x as a test, null files can have the exec bit set... that's bash for you...
# if $SCRIPT exists, it will handle the root tests. Root tests cannot
# be run first because they kill the -h help function
if [ -x "${PREFIX}${SCRIPT}" ]; then
	# I'm just going to put a test for basically everything that can go wrong
	# If we're lucky, this will handle partial or incomplete downloads that are not null
	exec "${PREFIX}${SCRIPT}" "$@" || error_handler 7
else
	# only in case of requirement to download script do root test, and just exit
	# if not root, anything else is counterintuitive I think for users.
	[ "$(id -u)" -ne 0 ] && error_handler 1
	
	# if and only if file does not exist and user is root do we make the temp file
	FILE_TEMP_NAME="$(mktemp -p $PREFIX $CALLER.XXXXXXXXXX)"
	# now we'll use a simple -f test since the null case is already handled. We are not
	# downloading to overwrite existing file, but to temp file, which we then test for null
	# -O is risky here too because failed downloads create a null file automatically.
	if [ ! -f "${PREFIX}${SCRIPT}" ]; then
		wget -q -O "${FILE_TEMP_NAME}" "${UPSTREAM}${SCRIPT}" || error_handler 4
	fi
	
	#  -s is prefered over -f because sometimes downloads fail and leave null size file
	# we're taking the temp file, testing it for null, then mv to correct file. Please do
	# not mess with these tests at all unless you can make them even more robust. No -f
	# is required because if wget exits with error then script exits. And if no error,
	# file will be null or existent and not null. I am adding another -f test here because
	# wget is so buggy I simply cannot predict its failure behaviors at all.
	if [ ! -e "${FILE_TEMP_NAME}" ]; then
		error_handler 6
	# if exists and not null
	elif [ ! -s "${FILE_TEMP_NAME}" ]; then
		error_handler 2
	# I'm being extra careful here, there have been too many problems with this simple
	# stuff... wget needs to be fixed to handle failed downloads better... what is  missing
	# is a null file test, as opposed to exists AND null.
	elif [ -s "${FILE_TEMP_NAME}" ]; then
		# now that the file exists and is not null
		mv -f "${FILE_TEMP_NAME}" "${PREFIX}${SCRIPT}"
		
		# make executable if not
		[ ! -x "${PREFIX}${SCRIPT}" ] && chmod +x "${PREFIX}${SCRIPT}"
		
		# then run it with an error handler for unknown weirdness which I'm sure will appear.
		if [ -x "${PREFIX}${SCRIPT}" ]; then
			# I'm just going to put a test for basically everything that can go wrong
			# If we're lucky, this will handle partial or incomplete downloads that are not null
			exec "${PREFIX}${SCRIPT}" "$@" || error_handler 7
		else
			error_handler 3
		fi
	fi
fi

